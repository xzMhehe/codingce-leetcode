## Redis

`Redis`是一个开源的内存中的数据结构存储系统，它可以用作：数据库、缓存和消息中间件。它支持多种类型的数据结构，如字符串（`String`），散列（`Hash`），列表（`List`），集合（`Set`）， 有序集合（`Sorted Set`或者是`ZSet`）与范围查询，`Bitmaps`，`Hyperloglogs` 和地理空间（Geospatial）索引半径查询。 其中常见的数据结构类型有：`String`、`List`、`Set`、`Hash`、`ZSet`这**5**种。

Redis 内置了复制（Replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction）， 事务（Transactions） 和不同级别的磁盘持久化（Persistence）， 并通过 Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（High Availability）。

> Redis也提供了持久化的选项，这些选项可以让用户将自己的数据保存到磁盘上面进行存储。 根据实际情况，可以每隔一定时间将数据集导出到磁盘（快照），或者追加到命令日志中（AOF只追加文件）， 他会在执行写命令时，将被执行的写命令复制到硬盘里面。您也可以关闭持久化功能，将Redis作为一个高效的网络的缓存数据功能使用。

Redis不使用表，他的数据库不会预定义或者强制去要求用户对Redis存储的不同数据进行关联。

数据库的工作模式按存储方式可分为：硬盘数据库和内存数据库。`Redis 将数据储存在内存里面，读写数据的时候都不会受到硬盘 I/O 速度的限制，所以速度极快`。

### **Redis为什么这么快**

- 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；
- 数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；
- 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
- 使用多路I/O复用模型，非阻塞IO；
- 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；

### 多路 I/O 复用模型

多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。

这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。

采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。

### Redis为什么是单线程的

>  官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。

1、这里我们一直在强调的单线程，只是在`处理我们的网络请求`的时候只有一个线程来处理，一个正式的Redis Server运行的时候肯定是不止一个线程的，这里需要大家明确的注意一下！ 例如Redis进行持久化的时候会以子进程或者子线程的方式执行（具体是子线程还是子进程待读者深入研究）

2、从Redis 4.0版本开始会支持多线程的方式，但是，只是在某一些操作上进行多线程的操作！以后的版本中是否还是单线程的方式需要考证！



## ObjectiveC混编 C++

纯C++类：只需要分别创建对应的 .h 和 .cpp 文件，直接导入工程并配置到对应TARGETS 的Compile Sources 下 ，如果需要使用C++标准库，还需要导入libc++库。

混编文件 .mm 文件：如果你想创建一个能即识别C++又识别OC的对象，只需要照常创建一个.h 文件和.m文件，然后将.m文件重命名成.mm文件，就是告诉编译器，这个文件可以进行混编 — ObjectiveC++。

纯OC类: .m文件和对应的头文件。

.h 需要保持各自的数据结构，保证纯正的C++ 或 OC；

将需要混编引用的.m 或者 .cpp文件的后缀修改为 .mm ，告诉编译器 这个文件可以进行混编 --- ObjectiveC++；

Objective-C 和 C++ 都是向下兼容 C的，可以通过灵活的使用 `void *`指针 作为纽带在两者之间传递对象；

## C++智能指针

在实际的 C++ 开发中，我们经常会遇到诸如程序运行中突然崩溃、程序运行所用内存越来越多最终不得不重启等问题，这些问题往往都是内存资源管理不当造成的。比如：

- 有些内存资源已经被释放，但指向它的指针并没有改变指向（成为了野指针），并且后续还在使用；

- 有些内存资源已经被释放，后期又试图再释放一次（重复释放同一块内存会导致程序运行崩溃）；
- 没有及时释放不再使用的内存资源，造成内存泄漏，程序占用的内存资源越来越多。

针对以上这些情况，很多程序员认为 C++ 语言应该提供更友好的内存管理机制，这样就可以将精力集中于开发项目的各个功能上。事实上，显示内存管理的替代方案很早就有了，早在 1959 年前后，就有人提出了“垃圾自动回收”机制。所谓垃圾，指的是那些不再使用或者没有任何指针指向的内存空间，而“回收”则指的是将这些“垃圾”收集起来以便再次利用。

C++ 标准模板库 STL（Standard Template Library） 一共给我们提供了四种智能指针：`auto_ptr`、`unique_ptr`、`shared_ptr` 和 `weak_ptr`，其中 `auto_ptr` 是 `C++98` 提出的，C++11 已将其摒弃，并提出了 `unique_ptr` 替代 `auto_ptr`。虽然 auto_ptr 已被摒弃，但在实际项目中仍可使用，但建议使用更加安全的 unique_ptr，后文会详细叙述。**shared_ptr** 和 **weak_ptr** 则是 C+11 从准标准库 **Boost** 中引入的两种智能指针。此外，Boost 库还提出了 **boost::scoped_ptr**、**boost::scoped_array**、**boost::intrusive_ptr** 等智能指针，虽然尚未得到 C++ 标准采纳，但是在开发实践中可以使用。 

### unique_ptr

unique_ptr 由 C++11 引入，旨在替代不安全的 auto_ptr。unique_ptr 是一种定义在头文件<memory>中的智能指针。它持有对对象的独有权——两个unique_ptr 不能指向一个对象，即 unique_ptr 不共享它所管理的对象。它无法复制到其他 unique_ptr，无法通过值传递到函数，也无法用于需要副本的任何标准模板库 （STL）算法。只能移动 unique_ptr，即对资源管理权限可以实现转移。这意味着，内存资源所有权可以转移到另一个 unique_ptr，并且原始 unique_ptr 不再拥有此资源。实际使用中，建议将对象限制为由一个所有者所有，因为多个所有权会使程序逻辑变得复杂。因此，当需要智能指针用于存 C++ 对象时，可使用 unique_ptr，构造 unique_ptr 时，可使用 make_unique Helper 函数。

```cpp
// 智能指针的创建
unique_ptr<int> u_i; 	//创建空智能指针
u_i.reset(new int(3)); 	//绑定动态对象  
unique_ptr<int> u_i2(new int(4));//创建时指定动态对象
unique_ptr<T,D> u(d);	//创建空 unique_ptr，执行类型为 T 的对象，用类型为 D 的对象 d 来替代默认的删除器 delete

// 所有权的变化  
int *p_i = u_i2.release();	//释放所有权  
unique_ptr<string> u_s(new string("abc"));  
unique_ptr<string> u_s2 = std::move(u_s); //所有权转移(通过移动语义)，u_s所有权转移后，变成“空指针” 
u_s2.reset(u_s.release());	//所有权转移
u_s2=nullptr;//显式销毁所指对象，同时智能指针变为空指针。与u_s2.reset()等价
```

### auto_ptr

auto_ptr 同样是 STL 智能指针家族的成员之一，由 C++98 引入，定义在头文件<memory>。其功能和用法类似于 unique_ptr，由 new expression 获得对象，在 auto_ptr 对象销毁时，他所管理的对象也会自动被 delete 掉。

auto_ptr 从 C++98 使用至今，为何从 C++11 开始，引入 unique_ptr 来替代 auto_ptr 呢？原因主要有如下几点：

- 基于安全考虑。
- unique_ptr 不仅安全，而且灵活。
- 扩展 auto_ptr 不能完成的功能。
  - unique_ptr 可放在容器中，弥补了 auto_ptr 不能作为容器元素的缺点。
  - 管理动态数组，因为 unique_ptr 有 unique_ptr<X[]> 重载版本，销毁动态对象时调用 delete[]。
  - 自定义资源删除操作（Deleter）。unique_ptr 默认的资源删除操作是 delete/delete[]，若需要可以进行自定义。

综上所述，基于 unique_ptr 的安全性和扩充的功能，unique_ptr 成功的将 auto_ptr 取而代之。

### shared_ptr

shared_ptr 是一个标准的共享所有权的智能指针，允许多个指针指向同一个对象，定义在 memory 文件中，命名空间为 std。shared_ptr最初实现于Boost库中，后由 C++11 引入到 C++ STL。shared_ptr 利用引用计数的方式实现了对所管理的对象的所有权的分享，即允许多个 shared_ptr 共同管理同一个对象。像 shared_ptr 这种智能指针，《Effective C++》称之为“引用计数型智能指针”（reference-counting smart pointer，RCSP）。

## weak_ptr

weak_ptr 被设计为与 shared_ptr 共同工作，可以从一个 shared_ptr 或者另一个 weak_ptr 对象构造而来。weak_ptr 是为了配合 shared_ptr 而引入的一种智能指针，它更像是 shared_ptr 的一个助手而不是智能指针，因为它不具有普通指针的行为，没有重载 operator* 和 operator-> ，因此取名为 weak，表明其是功能较弱的智能指针。它的最大作用在于协助 shared_ptr 工作，可获得资源的观测权，像旁观者那样观测资源的使用情况。观察者意味着 weak_ptr 只对 shared_ptr 进行引用，而不改变其引用计数，当被观察的 shared_ptr 失效后，相应的 weak_ptr 也相应失效。

### 选用

- 如果程序要使用多个指向同一个对象的指针，应选择 shared_ptr。

- 如果程序不需要多个指向同一个对象的指针，则可使用 unique_ptr。

- 虽然说在满足 unique_ptr 要求的条件时，使用 auto_ptr 也可以完成对内存资源的管理，但是因为 auto_ ptr 不够安全，不提倡使用，即任何情况下都不应该使用 auto_ptr。

- 为了解决 shared_ptr 的循环引用问题，我们可以祭出 weak_ptr。

- 在局部作用域（例如函数内部或类内部），且不需要将指针作为参数或返回值进行传递的情况下，如果对性能要求严格，使用 scoped_ptr 的开销较 shared_ptr 会小一些。



## 了解强引用、软引用、弱引用、虚引用

### 强引用（StrongReference）

强引用是开发过程中最常用的引用方式，当一个对象具有强引用时，操作系统进行 GC 回收处理是不会回收强引用的对象，即使系统内存不足，

Java虚拟机宁可抛 OutOfMemoryError(内存溢出错误)，宁可使程序异常终止，也不会靠回收强引用的对象来解决内存不足的问题。只要把强引用对象 str 赋空值 null, 该对象就可以被 GC 垃圾回收器回收；因为该对象此时不再含有其他强引用。

### 软引用（SoftReference）

当JVM虚拟机内存充足时，软引用对象不会被 GC 垃圾回收器回收。

当JVM虚拟机内存不足时，软引用对象会被 GC 垃圾回收器回收。

未被回收的软引用对象是一直会被程序占有的。

### 弱引用（WeakReference）

对于弱引用对象，当操作系统进行 GC 回收处理时，不管内存空间是否足够，弱引用对象都会被回收。

如果一个对象除了具有弱引用还具有强引用，GC回收时，该对象是不会被回收的，操作系统只会回收只具有弱引用的对象。弱引用常常被用于防止内存泄漏，最常见的是单例和Handler造成的内存泄漏。

### 虚引用（PhantomReference）

虚引用不能保证其保存对象生命周期，若保存对象只有虚引用，则其有效期完全随机于GC的回收，在任何一个不确定的时间内，都可能会被回收；而虚引用与其他几者的引用不同在于，在使用PhantomReference，必须要和Reference联合使用。


## Linux常用命令

**ls**命令：就是 list 的缩写，通过 ls 命令不仅可以查看 linux 文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。

```bash
ls -a 列出目录所有文件，包含以.开始的隐藏文件
ls -A 列出除.及..的其它文件
ls -r 反序排列
ls -t 以文件修改时间排序
ls -S 以文件大小排序
ls -h 以易读大小显示
ls -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来
```

**cd** 命令：目录。

**lsof** 命令：(list open files)是一个列出当前系统打开文件的工具。lsof 可查看端口占用情况；**netstat -tunlp命令**也可以，netstat -tunlp | grep 端口号。

**ps** 命令：ps(process status)，用来查看当前运行的进程状态，一次性查看，如果需要动态连续结果使用 top。

**kill**：杀死进程。

**pwd** 命令：用于查看当前工作目录路径。

**rm** 命令：删除一个目录中的一个或多个文件或目录，如果没有使用 -r 选项，则 rm 不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状。

**mv** 命令：移动文件或修改文件名，根据第二参数类型（如目录，则移动文件；如为文件则重命令该文件）。

**cp** 命令：将源文件复制至目标文件，或将多个源文件复制至目标目录。

**cat** 命令：一次显示整个文件；从键盘创建一个文件；将几个文件合并为一个文件；

tail 命令：用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。

which 命令：在 linux 要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索：

```bash
which     	查看可执行文件的位置。
whereis 		查看文件的位置。
locate  		配合数据库查看文件位置。
find        实际搜寻硬盘查询文件名称。
```

chmod 命令：用于改变 linux 系统文件或目录的访问权限。

df 命令：显示磁盘空间使用情况。

wc 命令：wc(word count)功能为统计指定的文件中字节数、字数、行数，并将统计结果输出

```bash
-c 统计字节数
-l 统计行数
-m 统计字符数
-w 统计词数，一个字被定义为由空白、跳格或换行字符分隔的字符串
```

## Java 拷贝

### 引用拷贝

引用拷贝会生成一个新的对象引用地址，但是两个最终指向依然是同一个对象

### 浅拷贝

浅拷贝会创建一个新对象，新对象和原对象本身没有任何关系，**新对象和原对象不等，但是新对象的属性和老对象相同**。

浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点）。

### 深拷贝

**在对引用数据类型进行拷贝的时候，创建了一个新的对象，并且复制其内的成员变量。**深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。

## mybatis 和 mybatisplus 的区别？

MyBatis前身是iBatis，是Clinton Begin在2001年发起的一个开源项目。最初侧重于码软件开发，后续发展成为一款基于java的持久层框架。Mybatis是一款优秀的持久层框架支持自定义SQL查询、存储过程和高级映射，消除了几乎所有的JDBC代码和参数的手动设置以及结果集的检索。MyBatis可以使用简单的XML或者注解进行映射和配置，通过将参数映射到配置的SQL最终解析为执行的SQL语句，查询后将SQl结果集映射成java对象返回。MyBatis提供的持久层框架包括SQL Maps（Mapper）和Data Access Objects（DAO），相对于Hibernate而言它提供的是一种把自动化的ORM实现。MyBatis中一级缓存会默认启用（本地缓存）且不受控制，一般说缓存时指的是MyBatis的二级缓存。

**MyBatis-plus**是一款MyBatis的增强工具，在MyBatis 的基础上只做增强不做改变。其是国内团队苞米豆在MyBatis基础上开发的增强框架，扩展了一些功能，以提高效率。引入 Mybatis-Plus 不会对现有的 Mybatis 构架产生任何影响，而且 MyBatis-plus 支持所有 Mybatis 原生的特性。

1、依赖少：仅仅依赖 Mybatis 以及 Mybatis-Spring 。

2、损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 。

3、预防Sql注入：内置 Sql 注入剥离器，有效预防Sql注入攻击 。

4、通用CRUD操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 。

5、多种主键策略：支持多达4种主键策略（内含分布式唯一ID生成器），可自由配置，完美解决主键问题 。

6、支持热加载：Mapper 对应的 XML 支持热加载，对于简单的 CRUD 操作，甚至可以无 XML 启动

7、支持ActiveRecord：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可实现基本 CRUD 操作

8、支持代码生成：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码（生成自定义文件，避免开发重复代码），支持模板引擎、有超多自定义配置等。

9、支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ）。

10、支持关键词自动转义：支持数据库关键词（order、key…）自动转义，还可自定义关键词 。

11、内置分页插件：基于 Mybatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通List查询。

12、内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能有效解决慢查询 。

13、内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，预防误操作。

14、默认将实体类的类名查找数据库中的表，使用@TableName(value="table1")注解指定表名，@TableId指定表主键，若字段与表中字段名保持一致可不加注解。

