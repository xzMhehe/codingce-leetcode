# C++基础
## 对多态的理解
多态按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。
C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。
## 浅拷贝和深拷贝的区别
深拷贝和浅拷贝区别是，在有指针的情况下，浅拷贝只是增加了一个指针指向已经存在的内存，而深拷贝就是增加一个指针并且申请一个新的内存，
使这个增加的指针指向这个新的内存，采用深拷贝的情况下，释放内存的时候就不会出现在浅拷贝时重复释放同一内存的错误。
## C++ 模板
模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。
模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。
每个容器都有一个单一的定义，比如 向量，我们可以定义许多不同类型的向量，比如 vector <int> 或 vector <string>。

## STL迭代器的实现原理

迭代器(iterator)是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器。除此之外，STL中迭代器一个最重要的作用就是作为容器(vector,list等)与STL算法的粘结剂，只要容器提供迭代器的接口，同一套算法代码可以利用在完全不同的容器中，这是抽象思想的经典应用。

## C++中的容器了解多少

一个容器是特定类型对象的集合，在C++标准库中包含了大部分常见的容器。STL 是“Standard Template Library”的缩写，中文译为“标准模板库”。STL 是 C++ 标准库的一部分，不用单独安装。TSL核心包括3个组件。容器(containers)，算法(algorithms)，迭代器(iterators)。除此外还有仿函数，内存配置器和配接器。

- 序列式容器（Sequence containers）：此为可序群集，其中每个元素均有固定位置—取决于插入时机和地点，和元素值无关。如果你以追加方式对一个群集插入六个元素，它们的排列次序将和插入次序一致。STL提供了三个序列式容器：向量（vector）、双端队列（deque）、列表（list），此外你也可以把 string 和 array 当做一种序列式容器。
- 关联式容器（Associative containers）：此为已序群集，元素位置取决于特定的排序准则以及元素值，和插入次序无关。如果你将六个元素置入这样的群集中，它们的位置取决于元素值，和插入次序无关。STL提供了四个关联式容器：集合（set）、多重集合（multiset）、映射（map）和多重映射（multimap）。

对于容器，主要的操作有：容器的建立、插入元素、删除元素、查询、遍历、计算元素个数、检查元素是否为空、输出容器包含的内容。


## Vector与Array的区别

- array定义后的空间是固定的了，不能改变；而vector要灵活得多，可再加或减.且只能包含整型字面值常量，枚举常量或者用常量 表达式初始化的整型const对象，非const变量以及需要到运行阶段才知道其值的const变量都不能用来定义数组的维度。
- 数组和vector不同，一个数组不能用另一个数组初始化，也不能将一个数组赋值给另一个数组；
- 在用下标访问元素时，vector 使用 vector::size_type 作为下标的类型，而数组下标的正确类型则是 size_t；
- vector 是STL中的容器类，包含多种通用算法,长度可变，使用灵活，但效率稍低。
- vector有一系列的函数操作，非常方便使用.和vector不同，数组不提供push——back或者其他的操作在数组中添加新元素，数组一经定义就不允许添加新元素； 若需要则要充许分配新的内存空间，再将员数组的元素赋值到新的内存空间。
- 和vector不同，数组不提供 push——back或者其他的操作在数组中添加新元素，数组一经定义就不允许添加新元素； 若需要则要充许分配新的内存空间，再将员数组的元素赋值到新的内存空间。

## **指针和引用的区别？**

指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用仅是个别名；

引用使用时无需解引用(*)，指针需要解引用；

引用只能在定义时被初始化一次，之后不可变；指针可变；

引用没有 const，指针有 const；

引用不能为空，指针可以为空；

“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；

指针和引用的自增(++)运算意义不一样；

指针可以有多级，但是引用只能是一级（int **p；合法 而 int &&a是不合法的）

从内存分配上看：程序为指针变量分配内存区域，而引用不需要分配内存区域。

## **解释下封装、继承和多态？**

封装：

封装是实现面向对象程序设计的第一步，封装就是将数据或函数等集合在一个个的单元中（我们称之为类）。封装的意义在于保护或者防止代码（数据）被我们无意中破坏。

继承：

继承主要实现重用代码，节省开发时间。子类可以继承父类的一些东西。

多态：

同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。



# 计算机网络
## TCP 和 UDP 的区别

**TCP**：传输控制协议，全称 Transmission Control Protocol ，是**面向连接**、可靠的、**基于字节流的**传输层协议。

**UDP**：支持无连接的一个传输协议，全称**用户数据报协议**（User Datagram Protocol）。UDP为应用程序提供了一种无需建立连接就可发送封装的数据包的方法。它不提供复杂的机制，只是利用IP来提供面向无连接的一种通信协议。

- TCP是面向连接的，通过三次握手建立连接，四次挥手解除连接；而UDP是面向无连接的，它发送数据是不需要建立连接的，这样大大的提高了它的传输效率，但是不能确保数据是否完整的传输。
- TCP是一种可靠的通信方式，TCP通过超时重传、确认应答、拥塞控制等机制来确保数据无差错、不丢包、不重复且有序；而UDP由于是无连接的，它会以最大的传输效率进行数据的传输，但不能保证数据传输的可靠交付，所以就会出现数据的丢失、重复等问题。
- TCP首部开销大占20个字节，而UDP的首部才占8个字节，开销小
- TCP协议提供可靠的、面向连接的传输服务，一般用于文件的传输、邮件的发送以及远程设备的控制；而UDP无需建立连接，传输效率高，不需要接收任何确认回复，可以用于即时的通信，例如QQ或WeChat的语言、视频通话以及抖音、斗鱼等平台的直播
- TCP因需要建立连接所以消耗资源大、而UDP不需要建立连接所以消耗资源小
- 每一条TCP连接只能是点到点的；而UDP不建立连接，所以可以支持一对一，一对多，多对一和多对多的交互通信，也就是可以同时接受多个人的包。

## OSI七层模型的简单介绍

网络模型不是一开始就有的，在网络刚发展时，网络协议是由各互联网公司自己定义的，各家的协议也是不能互通的。这样大大的阻碍了互联网的发展，为了解决这个问题，国际标准化组织 1984 提出的模型标准，简称 OSI（Open Systems Interconnection Model）。具体如下图：

OSI七层模型每一层都有自己的作用，从上到下的作用依次为：

- 应用层(Application) :提供网络与用户应用软件之间的接口服务
- 表示层(Presentation) :提供格式化的表示和转换数据服务，如加密和压缩
- 会话层(Session) 提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制
- 传输层(Transimission):提供建立、维护和取消传输连接功能，负责可靠地传输数据(PC)
- 网络层(Network): 处理网络间路由，确保数据及时传送(路由器)
- 数据链路层(DataLink): 负责无错传输数据，确认帧、发错重传等(交换机)
- 物理层(Physics) :提供机械、电气、功能和过程特性(网卡、网线、双绞线、同轴电缆、中继器)

七层中应用层、表示层和会话层由软件控制，传输层、网络层和数据链路层由操作系统控制，物理层有物理设备控制。

## TCP/IP参考模型及协议

模型：TCP/IP 模型是由 OSI 模型演化而来，TCP/IP 模型将 OSI 模型由七层简化为五层（一开始为四层），应用层、表示层、会话层统一为应用层。

<img src="https://cdn.jsdelivr.net/gh/xzMhehe/StaticFile_CDN/static/img/20210718152150.png" style="zoom:50%;" />

协议：TCP/IP协议被称为传输控制协议/互联网协议，又称网络通讯协议(Transmission Control Protocol)。是由网络层的IP协议和传输层的TCP协议组成，是一个很大的协议集合。

`物理层和数据链路层`没有定义任何特定协议，`支持所有的标准和专用的协议`。
`网络层`定义了`网络互联`也就是`IP协议`，主要包括`IP`、`ARP`、`RARP`、`ICMP`、`IGMP`。
`传输层`定义了`TCP`和`UDP`(User Datagram Protocol)，我们会后面重点介绍一下TCP协议。
`应用层`定义了`HTTP`(超文本传输协议)、`FTP`(文件传输协议)、`DNS`(域名系统)等协议。

## 搜索baidu，会用到计算机网络中的什么层？每层是干什么的

浏览器中输入URL
浏览器要将URL解析为IP地址，解析域名就要用到DNS协议，首先主机会查询DNS的缓存，如果没有就给本地DNS发送查询请求。DNS查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。

得到IP地址后，浏览器就要与服务器建立一个http连接。因此要用到http协议，http协议报文格式上面已经提到。http生成一个get请求报文，将该报文传给TCP层处理，所以还会用到TCP协议。如果采用https还会使用https协议先对http数据进行加密。TCP层如果有需要先将HTTP数据包分片，分片依据路径MTU和MSS。TCP的数据包然后会发送给IP层，用到IP协议。IP层通过路由选路，一跳一跳发送到目的地址。当然在一个网段内的寻址是通过以太网协议实现(也可以是其他物理层协议，比如PPP，SLIP)，以太网协议需要直到目的IP地址的物理地址，有需要ARP协议。

其中：

**1、DNS协议，http协议，https协议属于应用层**

应用层是体系结构中的最高层。应用层确定进程之间通信的性质以满足用户的需要。这里的进程就是指正在运行的程序。应用层不仅要提供应用进程所需要的信息交换和远地操作，而且还要作为互相作用的应用进程的用户代理，来完成一些为进行语义上有意义的信息交换所必须的功能。应用层直接为用户的应用进程提供服务。

**2、TCP/UDP属于传输层**

传输层的任务就是负责主机中两个进程之间的通信。因特网的传输层可使用两种不同协议：即面向连接的传输控制协议TCP，和无连接的用户数据报协议UDP。面向连接的服务能够提供可靠的交付，但无连接服务则不保证提供可靠的交付，它只是“尽最大努力交付”。这两种服务方式都很有用，备有其优缺点。在分组交换网内的各个交换结点机都没有传输层。

**3、IP协议，ARP协议属于网络层**

网络层负责为分组交换网上的不同主机提供通信。在发送数据时，网络层将运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，分组也叫作IP数据报，或简称为数据报。网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组能够交付到目的主机。

**4、数据链路层**

当发送数据时，数据链路层的任务是将在网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上传送以帧为单位的数据。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制、以及流量控制信息等）。控制信息使接收端能够知道—个帧从哪个比特开始和到哪个比特结束。控制信息还使接收端能够检测到所收到的帧中有无差错。

**5、物理层**

物理层的任务就是透明地传送比特流。在物理层上所传数据的单位是比特。传递信息所利用的一些物理媒体，如双绞线、同轴电缆、光缆等，并不在物理层之内而是在物理层的下面。因此也有人把物理媒体当做第0层。

## 请你说一说TCP拥塞控制？以及达到什么情况的时候开始减慢增长的速度？

拥塞控制是防止过多的数据注入网络，使得网络中的路由器或者链路过载。流量控制是点对点的通信量控制，而拥塞控制是全局的网络流量整体性的控制。发送双方都有一个拥塞窗口——cwnd。

**1、慢开始**

最开始发送方的拥塞窗口为1，由小到大逐渐增大发送窗口和拥塞窗口。每经过一个传输轮次，拥塞窗口cwnd加倍。当cwnd超过慢开始门限，则使用拥塞避免算法，避免cwnd增长过大。

**2、拥塞避免**

每经过一个往返时间RTT，cwnd就增长1。

在慢开始和拥塞避免的过程中，一旦发现网络拥塞，就把慢开始门限设为当前值的一半，并且重新设置cwnd为1，重新慢启动。（乘法减小，加法增大）

**3、快重传**

接收方每次收到一个失序的报文段后就立即发出重复确认，发送方只要连续收到三个重复确认就立即重传（尽早重传未被确认的报文段）。

**4、快恢复**

当发送方连续收到了三个重复确认，就乘法减半（慢开始门限减半），将当前的cwnd设置为慢开始门限，并且采用拥塞避免算法（连续收到了三个重复请求，说明当前网络可能没有拥塞）。

采用快恢复算法时，慢开始只在建立连接和网络超时才使用。

达到什么情况的时候开始减慢增长的速度？

**采用慢开始和拥塞避免算法的时候**

- 一旦cwnd>慢开始门限，就采用拥塞避免算法，减慢增长速度
- 一旦出现丢包的情况，就重新进行慢开始，减慢增长速度

**采用快恢复和快重传算法的时候**

- 一旦cwnd>慢开始门限，就采用拥塞避免算法，减慢增长速度
- 一旦发送方连续收到了三个重复确认，就采用拥塞避免算法，减慢增长速度

## 为什么连接的时候是三次握手

**刚开始客户端处于 closed 的状态，服务端处于 listen 状态**。然后

**第一次握手**：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 **ISN(c)**。此时客户端处于 **SYN_Send** 状态。

**第二次握手**：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 **SYN_RCVD** 的状态。

**第三次握手**：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 **established** 状态。

服务器收到 ACK 报文之后，也处于 **established 状态**，此时，双方以建立起了链接。

**三次握手的作用**

三次握手的作用也是有好多的，多记住几个，保证不亏。例如：

1、确认双方的接受能力、发送能力是否正常。

2、指定自己的初始化序列号，为后面的可靠传送做准备。

## 关闭的时候却是四次挥手

刚开始双方都处于 establised 状态，假如是客户端先发起关闭请求，则：

**第一次挥手**：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于**FIN_WAIT1**状态。

**第二次挥手**：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 **CLOSE_WAIT**状态。

**第三次挥手**：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 **LAST_ACK** 的状态。

**第四次挥手**：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 **TIME_WAIT**状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态。

服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。




## TCP ，UDP协议属于哪一层

传输层。

## HTTP协议属于哪一层？IP协议属于哪一层

应用层；网络层。


# 操作系统
## 进程和线程的区别

- 进程是资源分配的最小单位，而线程是 CPU 调度的最小单位；
- 创建进程或撤销进程，系统都要为之分配或回收资源，操作系统开销远大于创建或撤销线程时的开销；
- 不同进程地址空间相互独立，同一进程内的线程共享同一地址空间。一个进程的线程在另一个进程内是不可见的；
- 进程间不会相互影响，而一个线程挂掉将可能导致整个进程挂掉；

## 并发和并行有什么区别

- 并发（concurrency）：把任务在不同的时间点交给处理器进行处理。在同一时间点，任务并不会同时运行。
- 并行（parallelism）：把每一个任务分配给每一个处理器独立完成。在同一时间点，任务一定是同时运行。

## 进程间通信方式有哪些？

进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。IPC 的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams 等。其中 Socket 和 Streams 支持不同主机上的两个进程 IPC。

**管道**

1. 它是半双工的，具有固定的读端和写端；
2. 它只能用于父子进程或者兄弟进程之间的进程的通信；
3. 它可以看成是一种特殊的文件，对于它的读写也可以使用普通的 read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。

**命名管道**

1. FIFO 可以在无关的进程之间交换数据，与无名管道不同；
2. FIFO 有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。

**消息队列**

1. 消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符 ID 来标识；
2. 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级；
3. 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除；
4. 消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。

**信号量**

1. 信号量（semaphore）是一个计数器。用于实现进程间的互斥与同步，而不是用于存储进程间通信数据；
2. 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存；
3. 信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作；
4. 每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数；
5. 支持信号量组。

**共享内存**

1. 共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区；
2. 共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。

## 什么是死锁？死锁产生的条件？

死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。 如下图所示：如果此时有一个线程 A，已经持有了锁 A，但是试图获取锁 B，线程 B 持有锁 B，而试图获取锁 A，这种情况下就会产生死锁。

- 互斥条件：一个资源每次只能被一个进程使用。
- 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
- 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。
- 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

## 如何解决线程死锁？

如果发生了死锁，那么**只要破坏死锁 4 个必要条件之一**中的任何一个，死锁问题就能被解决。

**如果想要打破互斥条件**，需要允许进程同时访问某些资源，这种方法受制于实际场景，不太容易实现条件；

**打破不可抢占条件**，这样需要允许进程强行从占有者那里夺取某些资源，或者简单一点理解，占有资源的进程不能再申请占有其他资源，必须释放手上的资源之后才能发起申请，这个其实也很难找到适用场景；

进程在运行前申请得到所有的资源，否则该进程不能进入准备执行状态。这个方法看似有点用处，但是它的缺点是可能导致资源利用率和进程并发性降低；

**避免出现资源申请环路**，即对资源事先分类编号，按号分配。这种方式可以有效提高资源的利用率和系统吞吐量，但是增加了系统开销，增大了进程对资源的占用时间。

如果我们在死锁检查时发现了死锁情况，那么就要努力消除死锁，使系统从死锁状态中恢复过来。消除死锁的几种方式：

最简单、最常用的方法就是进行系统的**重新启动**，不过这种方法代价很大，它意味着在这之前所有的进程已经完成的计算工作都将付之东流，包括参与死锁的那些进程，以及未参与死锁的进程；

**撤消进程，剥夺资源**。终止参与死锁的进程，收回它们占有的资源，从而解除死锁。这时又分两种情况：一次性撤消参与死锁的全部进程，剥夺全部资源；或者逐步撤消参与死锁的进程，逐步收回死锁进程占有的资源。一般来说，选择逐步撤消的进程时要按照一定的原则进行，目的是撤消那些代价最小的进程，比如按进程的优先级确定进程的代价；考虑进程运行时的代价和与此进程相关的外部作业的代价等因素；

**进程回退策略，即让参与死锁的进程回退到没有发生死锁前某一点处**，并由此点处继续执行，以求再次执行时不再发生死锁。虽然这是个较理想的办法，但是操作起来系统开销极大，要有堆栈这样的机构记录进程的每一步变化，以便今后的回退，有时这是无法做到的

# 算法
## 快速排序的实现原理

快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。

```cpp
//
// Created by mxz on 2022/12/19.
//

#include<iostream>

using namespace std;

/**
 * 严蔚敏《数据结构》标准分割函数
 *
 * @param A
 * @param low
 * @param high
 * @return
 */
int Paritition1(int A[], int low, int high) {
    int pivot = A[low];
    while (low < high) {
        while (low < high && A[high] >= pivot) {
            --high;
        }
        A[low] = A[high];
        while (low < high && A[low] <= pivot) {
            ++low;
        }
        A[high] = A[low];
    }
    A[low] = pivot;
    return low;
}

void QuickSort(int A[], int low, int high) //快排母函数
{
    if (low < high) {
        int pivot = Paritition1(A, low, high);
        QuickSort(A, low, pivot - 1);
        QuickSort(A, pivot + 1, high);
    }
}

int main() {

    int A[] = {2, 5, 1, 3, 4, 10};
    QuickSort(A, 0, sizeof(A) / sizeof(A[0]));
    for (int num: A) {
        cout << num << " ";
    }

    return 0;
}
```



