# JVM 内存结构

## 前言

Java虚拟机由三个子系统构成，分别是 **类加载子系统**，**JVM运行时数据区**和**执行引擎**组成。一个Class文件先要经过 类加载器–>运行时数据区–>执行引擎 最终才会被执行。

<img src="https://raw.githubusercontent.com/xzMhehe/StaticFile_CDN/main/static/img20230104125717.png" style="zoom:67%;" />

### 程序计数器

Java虚拟机一次可以支持多个线程（`多线程`）. 每个Java虚拟机线程都有自己的程序计数器，是线程私有的。在JVM中，多线程是通过**线程轮流切换并分配处理器执行时间**的方式来实现，在同一时刻**一个处理器内核只会执行一条线程**，处理器切换线程时并不会记录上一个线程执行到哪一个位置，所以为了线程切换后依然能恢复到上一次所执行到的位置，每个线程`都需要各自独立的程序计数器`（当前线程所执行的字节码的 `行号指示器`，生命周期与线程的生命周期一致）；

### 虚拟机栈

虚拟机栈也称为**Java栈**，Java每个main方法被执行的时候，JVM都会同步创建一个栈帧（Stack Frame），通过存储**局部变量表**（存放局部变量的一个表，存放各种基本数据类型对象引用）、**操作数栈**（作为方法调用的中转站使用，用来存放Java方法执行过程中产生的中间计算结果和计算过程中产生的临时变量）、**动态链接**（指向运行时常量池的方法引用）、**方法返回地址**（方法正常退出或异常退出的地址）等信息来支撑和完成方法的执行。栈帧就是虚拟机栈中的子单位。

栈只有入栈和出栈两种操作。入栈：每一次方法调用都会有一个对应的栈帧被压入栈中，也成为压栈。出栈：方法调用结束后，弹出，也成为弹栈。（LIFO）

优点：栈帧内数据共享：一个栈帧中内存数据共享，不同栈帧之间数据不共享，这样可以减少内存消耗存储速度：栈帧存取数据快，仅次于寄存器。

### 本地方法栈

本地方法栈就是Native Stack，与虚拟机栈所发挥的作用是差不做的，虚拟机栈是为虚拟机执行`Java方法`（例如最常见的`set和get方法`,还有自定义的方法等）服务(也就是执行字节码)，本地方法栈是为虚拟机使用到的`本地方法`（**Native**）服务。Navtive方法是Java通过JNI直接调用本地C/C++库，可以认为是Native方法相当于C/C++暴露给Java的一个接口，Java通过调用这个接口从而调用到C/C++方法。

### 方法区

方法区是各个线程共享的内存区域,它用于存储`已经被虚拟机加载类型信息`，`常量`，`静态变量`，`即时编译器编译后的代码缓存（JIT）`等数据。

**栈、堆、方法区的交互关系**

```java
HouDuanMaJiang newH = new HouDuanMaJiang();
```

HouDuanMaJiang：存放在元空间，也可以说方法区；newH：存放在Java栈的局部变量表中；new HouDuanMaJiang();：存放在Java堆。

方法区主要存放的是 `Class` ，而堆中主要存放的是 实例化的对象。

- `方法区（Method Area）` 与 `Java堆` 一样，是各个线程共享的内存区域；
- 方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的；
- 方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展；
- 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误： `Java.lang.OutofMemoryError：PermGen space`  或者 `java.lang.OutOfMemoryError:Metaspace`
- 关闭JVM就会释放这个区域的内存。

**HotSpot中方法区的演进**

在 JDK 7 及以前，习惯上把方法区，称为永久代。JDK 8 开始，完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）。

- 元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用**本地内存**；
- 永久代、元空间二者并不只是名字变了，内部结构也调整了；
- 根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出 OOM 异常；

**设置方法区大小**

方法区的大小不必是固定的，JVM 可以根据应用的需要动态调整。

**JDK7 及以前**

通过 `-xx:Permsize` 来设置永久代初始分配空间，默认值是 20.75M。

`-XX:MaxPermsize` 来设定永久代最大可分配空间，32 位机器默认是 64M，64 位机器模式是82M。

当JVM加载的类信息容量超过了这个值，会报异常 `OutofMemoryError:PermGen space` 。

 **JDK8 以后**

元数据区大小可以使用参数 `-XX:MetaspaceSize` 和 `-XX:MaxMetaspaceSize` 指定。

默认值依赖于平台。Windows 下， `-XX:MetaspaceSize` 是21M，- `XX:MaxMetaspaceSize` 的值是-1，即没有限制。
与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常 `OutOfMemoryError:Metaspace`

`-XX:MetaspaceSize` ：设置初始的元空间大小。对于一个 64 位的服务器端 JVM 来说，其默认的 `-xx:MetaspaceSize` 值为 21 MB。这就是初始的高水位线，一旦触及这个水位线，FullGC 将会被触发并卸载没用的类（即这些类对应的类加载器不再存活）然后这个高水位线将会重置。新的高水位线的值取决于 GC 后释放了多少元空间。如果释放的空间不足，那么在不超过 MaxMetaspaceSize 时，适当提高该值。如果释放空间过多，则适当降低该值。

如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到FullGC 多次调用。为了避免频繁地 GC，建议将 `-XX:MetaspaceSize` 设置为一个相对较高的值。