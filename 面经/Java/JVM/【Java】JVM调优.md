# 【Java】JVM调优

## 在生产环境下有过调优JVM的经历吗？

一般优化系统的思路是这样的：

- 一般来说**关系型数据库是先到瓶颈**，**首先排查是否为数据库的问题**：这个过程中就需要评估自己建的**索引**是否合理、是否需要引**入分布式缓存**、是否需要**分库分表**等等；
- 然后，会考虑是否需要**扩容**（横向和纵向都会考虑）：这个过程中会怀疑是系统的压力过大或者是系统的硬件能力不足导致系统频繁出现问题；
- 接着，**应用代码层面上排查并优化**：扩容是不能无止境的，这个过程中会审视自己写的代码是否存在资源浪费的问题，又或者是在逻辑上可存在优化的地方，比如说通过**并行**的方式处理某些请求；
- **JVM层面上排查并优化**：审视完代码之后，这个过程观察JVM是否存在多次GC问题等等；
- 最后，网络和操作系统层面排查：这个过程查看内存/CPU/网络/硬盘读写指标是否正常等等。

一般调优JVM会有几种指标可以参考：**吞吐量**、**停顿时间**和**垃圾回收频率**，基于这些指标，就有可能需要调整：

- 内存区域大小以及相关策略（比如整块堆内存占多少、新生代占多少、老年代占多少、Survivor占多少、晋升老年代的条件等等），比如（-Xmx：设置堆的最大值、-Xms：设置堆的初始值、-Xmn：表示年轻代的大小、-XX:SurvivorRatio：伊甸区和幸存区的比例等等，Ratio [ˈreɪʃiəʊ]），按经验来说：**IO密集型**的可以稍微把**年轻代**空间加大些，因为大多数对象都是在年轻代就会灭亡。**内存计算密集型**的可以稍微把**老年代**空间加大些，对象存活时间会更长些；
- 垃圾回收器（**选择合适的垃圾回收器**，以及各个垃圾回收器的各种调优参数）：-XX:+UseG1GC：指定 JVM 使用的垃圾回收器为 G1、-XX:MaxGCPauseMillis：设置目标停顿时间（[pɔːz]）、-XX:InitiatingHeapOccupancyPercent：当整个堆内存使用达到一定比例（[ɪˈnɪʃieɪtɪŋ] [hiːp] [ˈɒkjəpənsi] [pəˈsɛnt]），全局并发标记阶段 就会被启动等等；

一般是**遇到问题**之后才进行调优的，而遇到问题后需要利用各种的**工具**进行排查：

- 通过 **jps** 命令查看Java进程**基础**信息（进程号、主类）。这个命令很常用的就是用来看当前服务器有多少Java进程在运行，它们的进程号和加载主类是啥；
- 通过 **jstat** 命令查看Java进程**统计类**相关的信息（类加载、编译相关信息统计，各个内存区域GC概况和统计）。这个命令很常用于看GC的情况；
- 通过 **jinfo** 命令来查看和调整Java进程的**运行参数**；
- 通过 **jmap** 命令来查看Java进程的**内存信息**。这个命令很常用于把JVM内存信息dump到文件，然后再用MAT( Memory Analyzer tool 内存解析工具)把文件进行分析；
- 通过 **jstack** 命令来查看JVM**线程信息**。这个命令用常用语排查死锁相关的问题；
- 还有近期比较热门的 Arthas（阿里开源的诊断工具），涵盖了上面很多命令的功能且自带图形化界面。这也是我这边常用的排查和分析工具；

## JVM的JIT优化技术

JIT优化技术比较出名的有两种：**方法内联**和**逃逸分析**。

- 所谓方法内联就是把**目标方法**的代码复制到**调用的方法**中，避免发生真实的方法调用，因为每次方法调用都会生成栈帧（压栈出栈记录方法调用位置等等）会带来一定的性能损耗，所以**方法内联**的优化可以提高一定的性能，在JVM中也有相关的参数给予我们指定（-XX:MaxFreqInlineSize、-XX:MaxInlineSize）；
- 而**逃逸分析**则是判断一个对象是否被外部方法引用或外部线程访问的分析技术，如果**没有被引用**，就可以对其进行优化，比如说：
  - 锁消除（同步忽略）：该对象只在方法内部被访问，不会被别的地方引用，那么就一定是线程安全的，可以把锁相关的代码给忽略掉；
  - 栈上分配：该对象只会在方法内部被访问，直接将对象分配在**栈**中（Java默认是将对象分配在**堆**中，是需要通过JVM垃圾回收期进行回收，需要损耗一定的性能，而栈内分配则快很多）；
  - 标量替换/分离对象：当程序真正执行的时候可以不创建这个对象，而直接创建它的成员变量来代替。将对象拆分后，可以分配对象的成员变量在栈或寄存器上，原本的对象就无需分配内存空间了。

## JVM的常用参数

JVM的参数非常之多，这里只列举比较重要的几个，通过各种各样的搜索引擎也可以得知这些信息。

| 参数名称                   | 含义                                                       | 默认值               | 说明                                                         |
| -------------------------- | ---------------------------------------------------------- | -------------------- | ------------------------------------------------------------ |
| -Xms                       | 初始堆大小                                                 | 物理内存的1/64(<1GB) | 默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制. |
| -Xmx                       | 最大堆大小                                                 | 物理内存的1/4(<1GB)  | 默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制 |
| -Xmn                       | 年轻代大小(1.4or later)                                    |                      | 注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 老年代大小 + 持久代（永久代）大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8 |
| -XX:NewSize                | 设置年轻代大小(for 1.3/1.4)                                |                      |                                                              |
| -XX:MaxNewSize             | 年轻代最大值(for 1.3/1.4)                                  |                      |                                                              |
| -XX:PermSize               | 设置持久代(perm gen)初始值                                 | 物理内存的1/64       |                                                              |
| -XX:MaxPermSize            | 设置持久代最大值                                           | 物理内存的1/4        |                                                              |
| -Xss                       | 每个线程的堆栈大小                                         |                      | JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.根据应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了 |
| -XX:NewRatio               | 年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代) |                      | -XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。 |
| -XX:SurvivorRatio          | Eden区与Survivor区的大小比值                               |                      | 设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10 |
| -XX:+DisableExplicitGC     | 关闭System.gc()                                            |                      | 这个参数需要严格的测试                                       |
| -XX:PretenureSizeThreshold | 对象超过多大是直接在旧生代分配                             | 0                    | 单位字节 新生代采用Parallel ScavengeGC时无效另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象. |
| -XX:ParallelGCThreads      | 并行收集器的线程数                                         |                      | 此值最好配置与处理器数目相等 同样适用于CMS                   |
| -XX:MaxGCPauseMillis       | 每次年轻代垃圾回收的最长时间(最大暂停时间)                 |                      | 如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值.       |

其实还有一些打印及CMS方面的参数，这里就不以一一列举了

所有线程共享数据区大小=新生代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m。所以java堆中增大年轻代后，将会减小年老代大小（因为老年代的清理是使用fullgc，所以老年代过小的话反而是会增多fullgc的）。此值对系统性能影响较大，Sun官方推荐配置为Java堆的3/8。



