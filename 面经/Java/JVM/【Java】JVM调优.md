# 【Java】JVM调优

## 在生产环境下有过调优JVM的经历吗？

一般优化系统的思路是这样的：

- 一般来说**关系型数据库是先到瓶颈**，**首先排查是否为数据库的问题**：这个过程中就需要评估自己建的**索引**是否合理、是否需要引**入分布式缓存**、是否需要**分库分表**等等；
- 然后，会考虑是否需要**扩容**（横向和纵向都会考虑）：这个过程中会怀疑是系统的压力过大或者是系统的硬件能力不足导致系统频繁出现问题；
- 接着，**应用代码层面上排查并优化**：扩容是不能无止境的，这个过程中会审视自己写的代码是否存在资源浪费的问题，又或者是在逻辑上可存在优化的地方，比如说通过**并行**的方式处理某些请求；
- **JVM层面上排查并优化**：审视完代码之后，这个过程观察JVM是否存在多次GC问题等等；
- 最后，网络和操作系统层面排查：这个过程查看内存/CPU/网络/硬盘读写指标是否正常等等。

一般调优JVM会有几种指标可以参考：**吞吐量**、**停顿时间**和**垃圾回收频率**，基于这些指标，就有可能需要调整：

- 内存区域大小以及相关策略（比如整块堆内存占多少、新生代占多少、老年代占多少、Survivor占多少、晋升老年代的条件等等），比如（-Xmx：设置堆的最大值、-Xms：设置堆的初始值、-Xmn：表示年轻代的大小、-XX:SurvivorRatio：伊甸区和幸存区的比例等等，Ratio [ˈreɪʃiəʊ]），按经验来说：**IO密集型**的可以稍微把**年轻代**空间加大些，因为大多数对象都是在年轻代就会灭亡。**内存计算密集型**的可以稍微把**老年代**空间加大些，对象存活时间会更长些；
- 垃圾回收器（**选择合适的垃圾回收器**，以及各个垃圾回收器的各种调优参数）：-XX:+UseG1GC：指定 JVM 使用的垃圾回收器为 G1、-XX:MaxGCPauseMillis：设置目标停顿时间（[pɔːz]）、-XX:InitiatingHeapOccupancyPercent：当整个堆内存使用达到一定比例（[ɪˈnɪʃieɪtɪŋ] [hiːp] [ˈɒkjəpənsi] [pəˈsɛnt]），全局并发标记阶段 就会被启动等等；

一般是**遇到问题**之后才进行调优的，而遇到问题后需要利用各种的**工具**进行排查：

- 通过 **jps** 命令查看Java进程**基础**信息（进程号、主类）。这个命令很常用的就是用来看当前服务器有多少Java进程在运行，它们的进程号和加载主类是啥；
- 通过 **jstat** 命令查看Java进程**统计类**相关的信息（类加载、编译相关信息统计，各个内存区域GC概况和统计）。这个命令很常用于看GC的情况；
- 通过 **jinfo** 命令来查看和调整Java进程的**运行参数**；
- 通过 **jmap** 命令来查看Java进程的**内存信息**。这个命令很常用于把JVM内存信息dump到文件，然后再用MAT( Memory Analyzer tool 内存解析工具)把文件进行分析；
- 通过 **jstack** 命令来查看JVM**线程信息**。这个命令用常用语排查死锁相关的问题；
- 还有近期比较热门的 Arthas（阿里开源的诊断工具），涵盖了上面很多命令的功能且自带图形化界面。这也是我这边常用的排查和分析工具；

## JVM的JIT优化技术

JIT优化技术比较出名的有两种：**方法内联**和**逃逸分析**。

- 所谓方法内联就是把**目标方法**的代码复制到**调用的方法**中，避免发生真实的方法调用，因为每次方法调用都会生成栈帧（压栈出栈记录方法调用位置等等）会带来一定的性能损耗，所以**方法内联**的优化可以提高一定的性能，在JVM中也有相关的参数给予我们指定（-XX:MaxFreqInlineSize、-XX:MaxInlineSize）；
- 而**逃逸分析**则是判断一个对象是否被外部方法引用或外部线程访问的分析技术，如果**没有被引用**，就可以对其进行优化，比如说：
  - 锁消除（同步忽略）：该对象只在方法内部被访问，不会被别的地方引用，那么就一定是线程安全的，可以把锁相关的代码给忽略掉；
  - 栈上分配：该对象只会在方法内部被访问，直接将对象分配在**栈**中（Java默认是将对象分配在**堆**中，是需要通过JVM垃圾回收期进行回收，需要损耗一定的性能，而栈内分配则快很多）；
  - 标量替换/分离对象：当程序真正执行的时候可以不创建这个对象，而直接创建它的成员变量来代替。将对象拆分后，可以分配对象的成员变量在栈或寄存器上，原本的对象就无需分配内存空间了。

