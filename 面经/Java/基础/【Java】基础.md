## Java的4种引用

1、**强引用**是最常见的，只要把一个对象赋给一个引用变量，这个引用变量就是一个强引用，只要对象没有被置null，在GC时就不会被回收；

2、**软引用**相对弱化了一些，需要继承 SoftReference实现，如果内存充足，只有软引用指向的对象不会被回收。如果内存不足了，只有软引用指向的对象就会被回收；

3、**弱引用**又更弱了一些，需要继承WeakReference实现，只要发生GC，只有弱引用指向的对象就会被回收；

4、**虚引用**需要继承PhantomReference实现，跟踪对象垃圾回收的状态，当回收时通过引用队列做些「通知类」的工作。

## 内存泄漏问题该如何解决

内存泄漏，是指不再使用的对象仍然被引用，导致垃圾收集器无法回收它们的内存。由于不再使用的对象仍然无法清理，甚至这种情况可能会越积越多，最终导致致命的OutOfMemoryError。可以按照如下的思路来分析和解决内存泄漏问题：

1. 启用分析器

   Java分析器是通过应用程序监视和诊断内存泄漏的工具，它可以分析我们的应用程序内部发生的事情，例如如何分配内存。使用分析器，我们可以比较不同的方法并找到可以最佳利用资源的方式。

2. 启用详细垃圾收集日志

   通过启用详细垃圾收集日志，我们可以跟踪GC的详细进度。要启用该功能，我们需要将以下内容添加到JVM的配置当中：-verbose:gc。通过这个参数，我们可以看到GC内部发生的细节。

3. 使用引用对象

   我们还可以借助java.lang.ref包内置的Java引用对象来规避问题，使用java.lang.ref包，而不是直接引用对象，即使用对象的特殊引用，使得它们可以轻松地被垃圾收集。

4. Eclipse内存泄漏警告

   对于JDK1.5以及更高的版本中，Eclipse会在遇到明显的内存泄漏情况时显示警告和错误。因此，在Eclipse中开发时，我们可以定期地访问“问题”选项卡，并更加警惕内存泄漏警告。

5. 基准测试

   我们可以通过执行基准测试来衡量和分析Java代码的性能。通过这种方式，我们可以比较执行相同任务的替代方法的性能。这可以帮助我们选择更好的方法，并可以帮助我们节约内存。

6. 代码审查

   最后，我们总是采用经典的老方式来进行简单的代码演练。在某些情况下，即使这种看似微不足道的方法也有助于消除一些常见的内存泄漏问题。

## 说一说你对布隆过滤器的理解

布隆过滤器可以用很小的代价来估算出数据是否真实存在，相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。

布隆过滤器的数据结构是一个大型的位数组，而如果我们要映射一个值到布隆过滤器中，我们还需要使用多个不同的哈希函数来生成多个哈希值，并对每个生成的哈希值指向的位置设置为1。查询key是否存在时，每个哈希函数都利用这个key计算出一个哈希值，再根据哈希值计算一个位置。然后对比这些哈希函数在位数组中对应位置的数值，如果这几个位置中，有一个的位置值为0，则说明过滤器中不存在这个key。如果这几个位置中，所有位置的值都是1，就说明这个布隆过滤器中，极有可能存在这个key。之所以不是百分之百确定，是因为也可能是其他的key运算导致该位置为1。

**布隆过滤器思想**

如果想要判断一个元素是不是在一个集合里，一般想到的是将所有元素保存起来，然后通过比较确定。链表，树等等数据结构都是这种思路. 但是随着集合中元素的增加，我们需要的存储空间越来越大，检索速度也越来越慢(O(n),O(logn))。不过世界上还有一种叫作散列表（又叫哈希表，Hash table）的数据结构。它可以通过一个Hash函数将一个元素映射成一个位阵列（Bit array）中的一个点。这样一来，我们只要看看这个点是不是1就可以知道集合中有没有它了。这就是布隆过滤器的基本思想。

