# 排序算法

## 冒泡排序

思路：俩俩交换，大的放在后面，第一次排序后最大值已在数组末尾。因为俩俩交换，需要`n-1`趟排序（比如10个数，需要9趟排序）

```java
package cn.com.codingce.排序.冒泡排序;

import java.util.Arrays;

public class BubbleSort {
    public static void main(String[] args) {
        System.out.println(Arrays.toString(new BubbleSort().sort(new int[]{0, 2, 1, 5, 7, 6, 3})));
    }

    public int[] sort(int[] arr) {
        for (int i = 1; i < arr.length; i++) {
            // 设置标记，j循环未交换则退出本次循环，
            boolean flag = true;
            for (int j = 0; j < arr.length - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    int tmp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = tmp;
                    flag = false;
                }
            }
            // 0, 2, 1, 5, 7, 6, 3
            // 0, 1, 2, 5, 7, 6, 3
            // 0, 1, 2, 5, 7, 6, 3
            // 0, 1, 2, 5, 7, 6, 3
            // 0, 1, 2, 5, 6, 7, 3
            // 0, 1, 2, 5, 6, 3, 7
            if (flag) {
                break;
            }
        }
        return arr;
    }
}
```

output

```bash
[0, 1, 2, 3, 5, 6, 7]
```

## 选择排序

思路：选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间。

```java
package cn.com.codingce.排序.选择排序;

import java.util.Arrays;

/**
 *
 * @author inke219223m
 */
public class SelectionSort {

    public static void main(String[] args) {
        System.out.println(Arrays.toString(new SelectionSort().selectionSort(new int[]{1, 5, 2, 7, 3, 4, 9})));
    }

    public int[] selectionSort(int[] arr) {
        for (int i = 0; i < arr.length - 1; i++) {
            // 记住当下标
            int min = i;
            // 每轮需要比较的次数 N-i
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[j] < arr[min]) {
                    // 记录目前能找到的最小值元素的下标
                    min = j;
                }
            }
            // 将找到的最小值和i位置所在的值进行交换
            if (i != min) {
                int tmp = arr[i];
                arr[i] = arr[min];
                arr[min] = tmp;
            }
        }
        return arr;
    }
}
```

output

```bash
[1, 2, 3, 4, 5, 7, 9]
```

## 插入排序

思路：将一个元素插入到已有序的数组中，在初始时未知是否存在有序的数据，因此将元素**第一个元素看成是有序的**。当只有一个数时，则不需要插入了，因此需要`n-1`趟排序。

```java
package cn.com.codingce.排序.插入排序;

import java.util.Arrays;

public class InsertSort {

    public static void main(String[] args) {
        System.out.println(Arrays.toString(new InsertSort().insertSort(new int[]{1, 5, 2, 7, 3, 4, 9})));
    }

    private int[] insertSort(int[] sourceArray) {
        int len = sourceArray.length;
        // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的
        for (int i = 1; i < len; i++) {
            // 记录插入的数据
            int tmp = sourceArray[i];
            // 从已经排序的序列最右边的开始比较，找到比其小的数
            int j = i;
            while (j > 0 && tmp < sourceArray[j - 1]) {
                sourceArray[j] = sourceArray[j - 1];
                j--;
            }
            // 存在比其小的, 插入
            if (j != i) {
                sourceArray[j] = tmp;
            }
        }

        return sourceArray;
    }

}
```

output

```bash
[1, 2, 3, 4, 5, 7, 9]
```

**希尔排序**：希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。

```java
package cn.com.codingce.排序.插入排序;

import java.util.Arrays;

/**
 * 希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。
 *
 * @author mxz
 */
public class ShellSort {

    public static void main(String[] args) {
        System.out.println(Arrays.toString(new ShellSort().shellSort(new int[]{1, 5, 2, 7, 3, 4, 9})));
    }

    private int[] shellSort(int[] sourceArray) {
        int len = sourceArray.length;
        int temp;
        for (int step = len / 2; step >= 1; step /= 2) {
            for (int i = step; i < len; i++) {
                temp = sourceArray[i];
                // j - step 就是代表与它同组隔壁的元素
                int j = i - step;
                while (j >= 0 && sourceArray[j] > temp) {
                    sourceArray[j + step] = sourceArray[j];
                    j -= step;
                }
                sourceArray[j + step] = temp;
            }
        }
        return sourceArray;
    }

}
```

## 快速排序

