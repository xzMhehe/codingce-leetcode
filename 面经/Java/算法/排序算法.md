# 排序算法

## 冒泡排序

思路：俩俩交换，大的放在后面，第一次排序后最大值已在数组末尾。因为俩俩交换，需要`n-1`趟排序（比如10个数，需要9趟排序）

```java
package cn.com.codingce.排序.冒泡排序;

import java.util.Arrays;

public class BubbleSort {
    public static void main(String[] args) {
        System.out.println(Arrays.toString(new BubbleSort().sort(new int[]{0, 2, 1, 5, 7, 6, 3})));
    }

    public int[] sort(int[] arr) {
        for (int i = 1; i < arr.length; i++) {
            // 设置标记，j循环未交换则退出本次循环，
            boolean flag = true;
            for (int j = 0; j < arr.length - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    int tmp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = tmp;
                    flag = false;
                }
            }
            // 0, 2, 1, 5, 7, 6, 3
            // 0, 1, 2, 5, 7, 6, 3
            // 0, 1, 2, 5, 7, 6, 3
            // 0, 1, 2, 5, 7, 6, 3
            // 0, 1, 2, 5, 6, 7, 3
            // 0, 1, 2, 5, 6, 3, 7
            if (flag) {
                break;
            }
        }
        return arr;
    }
}
```

output

```bash
[0, 1, 2, 3, 5, 6, 7]
```

## 选择排序

思路：找到数组中最大的元素，与数组最后一位元素交换。当只有一个数时，则不需要选择了，因此需要`n-1`趟排序。

```java
package cn.com.codingce.排序.选择排序;

import java.util.Arrays;

/**
 * 找到数组中最大的元素，与数组最后一位元素交换。当只有一个数时，则不需要选择了，因此需要n-1趟排序
 *
 * @author inke219223m
 */
public class SelectionSort {

    public static void main(String[] args) {
        System.out.println(Arrays.toString(new SelectionSort().selectionSort(new int[]{1, 5, 2, 7, 3, 4, 9})));
    }

    public int[] selectionSort(int[] arr) {
        // 总共要经过 N-1 轮比较
        for (int i = 0; i < arr.length - 1; i++) {
            // 记住当下标
            int min = i;
            // 每轮需要比较的次数 N-i
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[j] < arr[min]) {
                    // 记录目前能找到的最小值元素的下标
                    min = j;
                }
            }
            // 将找到的最小值和i位置所在的值进行交换
            if (i != min) {
                int tmp = arr[i];
                arr[i] = arr[min];
                arr[min] = tmp;
            }
        }
        return arr;
    }
}
```

output

```bash
[1, 2, 3, 4, 5, 7, 9]
```

## 插入排序

思路：将一个元素插入到已有序的数组中，在初始时未知是否存在有序的数据，因此将元素**第一个元素看成是有序的**。与有序的数组进行比较，**比它大则直接放入，比它小则移动数组元素的位置，找到个合适的位置插入**。当只有一个数时，则不需要插入了，因此需要`n-1`趟排序。

```java
package cn.com.codingce.排序.插入排序;

import java.util.Arrays;

public class InsertSort {

    public static void main(String[] args) {
        System.out.println(Arrays.toString(new InsertSort().insertSort(new int[]{1, 5, 2, 7, 3, 4, 9})));
    }

    private int[] insertSort(int[] sourceArray) {
        int len = sourceArray.length;
        // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的
        for (int i = 1; i < len; i++) {
            // 记录插入的数据
            int tmp = sourceArray[i];
            // 从已经排序的序列最右边的开始比较，找到比其小的数
            int j = i;
            while (j > 0 && tmp < sourceArray[j - 1]) {
                sourceArray[j] = sourceArray[j - 1];
                j--;
            }
            // 存在比其小的, 插入
            if (j != i) {
                sourceArray[j] = tmp;
            }
        }

        return sourceArray;
    }

}
```

output

```bash
[1, 2, 3, 4, 5, 7, 9]
```

## 快速排序

